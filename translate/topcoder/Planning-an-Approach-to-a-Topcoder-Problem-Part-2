<!DOCTYPE html><html lang="vi"><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="UTF-8"><meta name="viewport" content="user-scalable=yes, width=device-width, initial-scale=1, maximum-scale=5"><meta name="theme-color" content="#1976d2"><meta name="msapplication-TileColor" content="#1976d2"><meta name="msapplication-TileImage" content="/_assets/favicons/mstile-150x150.png"><title>Những cách tiếp cận bài toán: Phần 2 | VNOI Wiki</title><meta name="description" content><meta property="og:title" content="Những cách tiếp cận bài toán: Phần 2"><meta property="og:type" content="website"><meta property="og:description" content><meta property="og:image"><meta property="og:url" content="wiki.vnoi.info/translate/topcoder/Planning-an-Approach-to-a-Topcoder-Problem-Part-2"><meta property="og:site_name" content="VNOI Wiki"><link rel="apple-touch-icon" sizes="180x180" href="/_assets/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="192x192" href="/_assets/favicons/android-chrome-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/_assets/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/_assets/favicons/favicon-16x16.png"><link rel="mask-icon" href="/_assets/favicons/safari-pinned-tab.svg" color="#1976d2"><link rel="manifest" href="/_assets/manifest.json"><script>var siteConfig = {"title":"VNOI Wiki","theme":"default","darkMode":false,"tocPosition":"right","lang":"vi","rtl":false,"company":"VNOI","contentLicense":"","footerOverride":"","logoUrl":"/uploads/vnoi.svg"}
var siteLangs = []
</script><link type="text/css" rel="stylesheet" href="/_assets/css/app.14bb5aad096a8ce1a4b0.css"><script type="text/javascript" src="/_assets/js/runtime.js?1703587860"></script><script type="text/javascript" src="/_assets/js/app.js?1703587860"></script><style type="text/css">.page-col-content{max-width:1012px!important;margin-left:auto;margin-right:auto;text-align:justify}.v-main a{text-decoration:none}</style></head><body><div id="root"><page locale="vi" path="translate/topcoder/Planning-an-Approach-to-a-Topcoder-Problem-Part-2" title="Những cách tiếp cận bài toán: Phần 2" description :tags="[]" created-at="2023-12-25T11:07:26.113Z" updated-at="2023-12-25T12:38:05.432Z" author-name="Administrator" :author-id="1" editor="markdown" :is-published="true" toc="W3sidGl0bGUiOiJOaOG7r25nIGPDoWNoIHRp4bq/cCBj4bqtbiBiw6BpIHRvw6FuOiBQaOG6p24gMiIsImFuY2hvciI6IiNuaOG7r25nLWPDoWNoLXRp4bq/cC1j4bqtbi1iw6BpLXRvw6FuLXBo4bqnbi0yIiwiY2hpbGRyZW4iOltdfSx7InRpdGxlIjoiVGnhur9wIGPhuq1uIHThu6sgZMaw4bubaSBsw6puIChCb3R0b20tdXAgUHJvZ3JhbW1pbmcpIiwiYW5jaG9yIjoiI3Rp4bq/cC1j4bqtbi104burLWTGsOG7m2ktbMOqbi1ib3R0b20tdXAtcHJvZ3JhbW1pbmciLCJjaGlsZHJlbiI6W119LHsidGl0bGUiOiJWw6l0IGPhuqFuIChCcnV0ZSBGb3JjZSkiLCJhbmNob3IiOiIjdsOpdC1j4bqhbi1icnV0ZS1mb3JjZSIsImNoaWxkcmVuIjpbXX0seyJ0aXRsZSI6IlPhu60gZOG7pW5nIGdp4bqjaSB0aHXhuq10IiwiYW5jaG9yIjoiI3Phu60tZOG7pW5nLWdp4bqjaS10aHXhuq10IiwiY2hpbGRyZW4iOltdfSx7InRpdGxlIjoiUGjDoXQgYmnhu4N1IGzhuqFpIGLDoGkgdG/DoW4gdGhlbyBjw6FjaCBraMOhYyIsImFuY2hvciI6IiNwaMOhdC1iaeG7g3UtbOG6oWktYsOgaS10b8Ohbi10aGVvLWPDoWNoLWtow6FjIiwiY2hpbGRyZW4iOltdfSx7InRpdGxlIjoiR+G7oSBi4buPIG5o4buvbmcgxJHhu4tuaCBuZ2jEqWEiLCJhbmNob3IiOiIjZ+G7oS1i4buPLW5o4buvbmctxJHhu4tuaC1uZ2jEqWEiLCJjaGlsZHJlbiI6W119LHsidGl0bGUiOiJCw6BpIHRvw6FuIGPDsyB0aOG7gyBnaeG6o2kgxJHGsOG7o2MiLCJhbmNob3IiOiIjYsOgaS10b8Ohbi1jw7MtdGjhu4MtZ2nhuqNpLcSRxrDhu6NjIiwiY2hpbGRyZW4iOltdfSx7InRpdGxlIjoiQ2hpYSB0csaw4budbmcgaOG7o3AiLCJhbmNob3IiOiIjY2hpYS10csaw4budbmctaOG7o3AiLCJjaGlsZHJlbiI6W119LHsidGl0bGUiOiJL4bq/IGhv4bqhY2ggYsOqbiB0cm9uZyBr4bq/IGhv4bqhY2giLCJhbmNob3IiOiIja+G6vy1ob+G6oWNoLWLDqm4tdHJvbmcta+G6vy1ob+G6oWNoIiwiY2hpbGRyZW4iOltdfSx7InRpdGxlIjoiVGhheSDEkeG7lWkgY8OhYyBjw6FjaCB0aeG6v3AgY+G6rW4iLCJhbmNob3IiOiIjdGhheS3EkeG7lWktY8OhYy1jw6FjaC10aeG6v3AtY+G6rW4iLCJjaGlsZHJlbiI6W119LHsidGl0bGUiOiJRdWF5IGx1aSBjw6FjIGPDoWNoIHRp4bq/cCBj4bqtbiBzYWkiLCJhbmNob3IiOiIjcXVheS1sdWktY8OhYy1jw6FjaC10aeG6v3AtY+G6rW4tc2FpIiwiY2hpbGRyZW4iOltdfSx7InRpdGxlIjoiS+G6v3QgbHXhuq1uIiwiYW5jaG9yIjoiI2vhur90LWx14bqtbiIsImNoaWxkcmVuIjpbXX0seyJ0aXRsZSI6Ik5o4buvbmcgYsOgaSB04bqtcCDEkcOjIMSR4buBIGPhuq1wIHThu5tpIiwiYW5jaG9yIjoiI25o4buvbmctYsOgaS104bqtcC3EkcOjLcSR4buBLWPhuq1wLXThu5tpIiwiY2hpbGRyZW4iOltdfV0=" :page-id="165" sidebar="W10=" nav-mode="NONE" comments-enabled effective-permissions="eyJjb21tZW50cyI6eyJyZWFkIjp0cnVlLCJ3cml0ZSI6ZmFsc2UsIm1hbmFnZSI6ZmFsc2V9LCJoaXN0b3J5Ijp7InJlYWQiOmZhbHNlfSwic291cmNlIjp7InJlYWQiOmZhbHNlfSwicGFnZXMiOnsicmVhZCI6dHJ1ZSwid3JpdGUiOmZhbHNlLCJtYW5hZ2UiOmZhbHNlLCJkZWxldGUiOmZhbHNlLCJzY3JpcHQiOmZhbHNlLCJzdHlsZSI6ZmFsc2V9LCJzeXN0ZW0iOnsibWFuYWdlIjpmYWxzZX19" edit-shortcuts="eyJlZGl0RmFiIjpmYWxzZSwiZWRpdE1lbnVCYXIiOmZhbHNlLCJlZGl0TWVudUJ0biI6ZmFsc2UsImVkaXRNZW51RXh0ZXJuYWxCdG4iOmZhbHNlLCJlZGl0TWVudUV4dGVybmFsTmFtZSI6IiIsImVkaXRNZW51RXh0ZXJuYWxJY29uIjoiIiwiZWRpdE1lbnVFeHRlcm5hbFVybCI6IiJ9" filename="translate/topcoder/Planning-an-Approach-to-a-Topcoder-Problem-Part-2.md"><template slot="contents"><div><h1 id="những-cách-tiếp-cận-bài-toán-phần-2" class="toc-header"><a class="toc-anchor" href="#những-cách-tiếp-cận-bài-toán-phần-2">¶</a> Những cách tiếp cận bài toán: Phần 2</h1>
<p>Bài viết bởi <a href="https://www.topcoder.com/members/leadhyena_inran/" class="is-external-link">leadhyena_inran</a>.</p>
<p>Nguồn: <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/planning-an-approach-to-a-topcoder-problem-part-2/" class="is-external-link">Topcoder</a></p>
<h1 id="tiếp-cận-từ-dưới-lên-bottom-up-programming" class="toc-header"><a class="toc-anchor" href="#tiếp-cận-từ-dưới-lên-bottom-up-programming">¶</a> Tiếp cận từ dưới lên (Bottom-up Programming)</h1>
<p>Kỹ thuật này ngược với kỹ thuật chia nhỏ vấn đề đã được nói đến ở <a href="/translate/topcoder/Planning-an-Approach-to-a-Topcoder-Problem-Part-1" class="is-internal-link is-valid-page">bài viết trước</a>, và nó nên là kỹ thuật đầu tiên bạn nghĩ tới khi bạn chưa tìm ra hướng giải. Bottom-up programming là phương pháp xuất phát từ những hàm cơ bản, chỉnh sửa, thêm tính năng, kết hợp chúng để giải được bài toán ban đầu. Nhiều lúc khi vừa đọc đề bạn sẽ thấy rằng bạn cần một hàm cụ thể nào đó để giải bài này, nếu nó đã atomic hay dễ dàng cài đặt thì bạn có thể có thể xây dựng thẳng lên từ những hàm cơ bản đó thay vì chia nhỏ ra.</p>
<p>Trong bài <a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=511&amp;rd=4335" class="is-external-link">MatArith</a> ở phần trước, chương trình con để cộng và nhân ma trận cũng có thể áp dụng kĩ thuật này. Bạn có thể viết một hàm <code>evalMult</code> nhỏ hơn có nhiệm vụ nhân các ma trận với nhau bằng cách xử lí luôn trên string, một hàm <code>evalAdd</code> tương tự để cộng ma trận.</p>
<p>Nói chung, xây dựng dần dần lên những chương trình con trước khi giải quyết vấn đề chính của bài toán là một chiến thuật khá tốt. Một vài ví dụ điển hình là các thao tác trên cấu trúc dữ liệu (data structures), các toán tử của ma trận, số phức... Bạn sẽ thấy rằng, bằng việc giải quyết những vấn đề nhỏ trước, bạn sẽ hình dung rõ hơn bạn cần làm gì. Thỉnh thoảng, nếu bạn bị bế tắc với cách này, thì hãy viết một vài dòng atomic code để xem việc chia nhỏ vấn đề ra thì có hợp lí hơn hay không. Như bạn thấy, để tìm được cách tiếp cận đúng thì phải thử để biết cách tiếp cận nào sai trước đã.</p>
<p>Bên cạnh đó, hãy nhớ rằng bất kì dòng code nào bạn viết ra đều phải được kiểm tra kĩ trước khi xây dựng lên cao, bởi vì đây là những dòng code đầu tiên bạn viết và bạn sẽ chóng quên khi càng viết lên những phần phía trên. Một mẹo khá hay để tìm lỗi: nó thường nằm trong những dòng code cũ của bạn.</p>
<h1 id="vét-cạn-brute-force" class="toc-header"><a class="toc-anchor" href="#vét-cạn-brute-force">¶</a> Vét cạn (Brute Force)</h1>
<p>Bất cứ khi nào đề bài yêu cầu một kết quả tối ưu, thì cách đơn giản nhất để giải quyết vấn đề là thử tất cả các trường hợp xảy ra. Bất cứ khi nào lời giải đòi hỏi việc tính toán nhiều bước, cách tốt nhất để giải là làm theo từng bước tính toán đó. Bất cứ khi nào bài toán yêu cầu bạn đếm những cách để làm một thứ gì đó trong một điều kiện cho trước, cách tốt nhất là thử tất cả mọi cách và chọn những cách thỏa yêu cầu. Nói cách khác, cách tiếp cận đầu tiên cho các bài toán nên là một cách dễ nhận thấy nhất, cho dù nó không phải là cách tốt nhất.</p>
<p>Chiến thuật tiếp cận này gọi là vét cạn (brute force) - xét qua tất cả các trường hợp có thể xảy ra để tìm kết quả. Mỗi khi bạn gặp một bài toán, đầu tiên phải xét đến là test xấu nhất có thể có là gì và liệu thời gian cho phép có đủ không. Nếu có thể, hãy brute force vì thường code sẽ đơn giản và ít mắc lỗi hơn. Bạn cũng phải có đủ kiến thức về môi trường lập trình (programming environment) để ước lượng thời gian chạy của chương trình. Có nhiều trường hợp do không ước lượng đúng nên đã bỏ qua cách brute force đơn giản và tốn thời gian vào debug những cách giải phức tạp, cũng tương tự như việc bị quá thời gian (time limit exceeded) khi không dự đoán được đến trường hợp xấu nhất.</p>
<p>Nói chung, nếu bạn không thể tìm ra được cách nào khác để giải, thì hãy dùng brute-force. Nếu không đủ nhanh, thì tiếp tục tìm cách khác tối ưu hơn. Sau đó chúng ta có thể sử dụng code brute-force để test cho những cách giải khác (vì code brute-force bao giờ khả năng mắc lỗi cũng thấp hơn).</p>
<h1 id="sử-dụng-giải-thuật" class="toc-header"><a class="toc-anchor" href="#sử-dụng-giải-thuật">¶</a> Sử dụng giải thuật</h1>
<p>Sử dụng những giải thuật cơ bản cũng là cách tiếp hiệu quả. Việc này cũng giống như việc đi các nước mở đầu giống nhau khi chơi cờ vậy. Thông thường, cách thử lần lượt các thuật toán để tiếp cận bài toán là một cách làm không hay cho lắm (nó tạo ra tư duy lối mòn và nhiều lỗ hổng kiến thức cho các bài toán cơ bản), nhưng nó cũng không phải là một ý tồi nếu sử dụng nó như một atomic code hay dựa vào đó để chia nhỏ vấn đề ra.</p>
<p>Bài này mình không bàn luận nhiều về giải thuật (đã có nhiều bài hướng dẫn về phần này), mà bàn về việc nên dùng giải thuật như thế nào để xác định cách tiếp cận bài toán. Biết cách sử dụng giải thuật trong trường hợp cơ bản là chưa đủ, hãy cố gắng hiểu thật sâu về nó. Ví dụ, bài <a href="http://topcoder.bgcoder.com/print.php?id=369" class="is-external-link">CityLink SRM 170 Div I Med</a>, dùng kết hợp các giải thuật đồ thị (graph algorithm) đơn giản để giải, ngược lại việc code một giải thuật thông thường thì không đủ. Chỉ có hiểu sâu về cách hoạt động của thuật toán mới có thể tìm ra được cách kết hợp chúng với nhau.</p>
<p>Vì vậy, khi học một giải thuật mới, bạn phải hiểu được code chạy như thế nào, độ phức tạp là bao nhiêu, phần nào của code có thể thay đổi được và ảnh hưởng như thế nào đến thuật toán. Việc nhớ cách code một giải thuật cũng cực kì quan trọng, bởi vì nếu không có kinh nghiệm cài đặt thì sẽ rất khó để tìm lỗi. Sử dụng thuật toán một cách sáng tạo để giải quyết nhiều bài toán khác nhau cũng là một cách luyện tập hữu ích. Ít ra thì ta có thể biết được những trường hợp nào không phù hợp để dùng thuật toán này. Đó là lý do tại sao nên học những kĩ thuật nền tảng như chia để trị (divide-and-conquer), quy hoạch động (dynamic programming), tham lam (greedy algorithms) trước những thuật toán cụ thể khác, bởi vì những kĩ thuật đó có thể dễ dàng tùy biến một khi bạn đã hiểu cách hoạt động.</p>
<h1 id="phát-biểu-lại-bài-toán-theo-cách-khác" class="toc-header"><a class="toc-anchor" href="#phát-biểu-lại-bài-toán-theo-cách-khác">¶</a> Phát biểu lại bài toán theo cách khác</h1>
<p>Tình huống này rất quen thuộc: bạn cảm thấy mình đuối sức bởi việc cố gắng tìm ra dạng bài của đề. Điều này xảy ra có lẽ vì đề bài cần phải biến đổi để tiếp cận được, khi biến đổi đề bài thì chúng ta sẽ dề dàng nhận ra vấn đề hơn. Ví dụ điển hình là bài <a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=1850&amp;rd=4665" class="is-external-link">Game of Fifteen - SRM 172</a>. Trong bài này, bạn có những con số từ 1 đến 9, bạn có thể lấy một trong những con số đó theo lượt, nếu bạn có 3 số trong các số bạn đã chọn có tổng bằng 15 trước đối thủ, bạn thắng. Với bài toán này, bạn có thể điều chỉnh lại đề bài bằng việc đặt các con số trong ma trận 3x3 (trong đó mỗi dòng, mỗi cột và đường chéo có tổng bằng nhau, trong trường hợp này là 15). Ngay lập tức bạn nhận ra rằng đây chỉ là trò chơi Tic-Tac-Toe. Việc thay đổi này đã biến một bài toán mà bạn chưa từng gặp, thành một bài toán bạn đã tiếp xúc nhiều hơn. Một số nhà toán học gọi nó là cách tiếp cận <svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="7.343ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 3245.7 833.9" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path><path id="MJX-1-TEX-I-1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path><path id="MJX-1-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-1-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-1-TEX-I-1D434"></use></g><g data-mml-node="mi" transform="translate(750,0)"><use data-c="1D435" xlink:href="#MJX-1-TEX-I-1D435"></use></g><g data-mml-node="msup" transform="translate(1509,0)"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-1-TEX-I-1D434"></use></g><g data-mml-node="TeXAtom" transform="translate(783,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><use data-c="2212" xlink:href="#MJX-1-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(778,0)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g></g></g></g></g></svg>, bởi vì: đầu tiên bạn thay đổi dạng đề bài <svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.457ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 1528 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-2-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path><path id="MJX-2-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><use data-c="28" xlink:href="#MJX-2-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(389,0)"><use data-c="1D434" xlink:href="#MJX-2-TEX-I-1D434"></use></g><g data-mml-node="mo" transform="translate(1139,0)"><use data-c="29" xlink:href="#MJX-2-TEX-N-29"></use></g></g></g></svg>, sau đó giải nó <svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.477ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 1537 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-3-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-3-TEX-I-1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path><path id="MJX-3-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><use data-c="28" xlink:href="#MJX-3-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(389,0)"><use data-c="1D435" xlink:href="#MJX-3-TEX-I-1D435"></use></g><g data-mml-node="mo" transform="translate(1148,0)"><use data-c="29" xlink:href="#MJX-3-TEX-N-29"></use></g></g></g></svg>, và trả ngược lại vấn đề ban đầu <svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="3.929ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 1736.7 833.9" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-4-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path><path id="MJX-4-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-4-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-4-TEX-I-1D434"></use></g><g data-mml-node="TeXAtom" transform="translate(783,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><use data-c="2212" xlink:href="#MJX-4-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(778,0)"><use data-c="31" xlink:href="#MJX-4-TEX-N-31"></use></g></g></g></g></g></svg>. Cách tiếp cận này rất phổ biến trong việc giải những bài toán phức tạp như <a href="http://mathworld.wolfram.com/MatrixDiagonalization.html" class="is-external-link">diagonalizing matrices</a> và giải Rubik.</p>
<p>Cách tiếp cận này được phổ biến để làm đơn giản đi những phép toán cơ bản. Ví dụ: <a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=2920&amp;rd=5852&amp;rm=&amp;cr=10225719" class="is-external-link">HexagonIntersections - SRM 206</a>. Trong bài toán này, chúng ta cần tìm số hình 6 cạnh chạm một đường thẳng cho trước. Bài toán trở nên đơn giản hơn nếu bạn lật nghiêng cái lưới qua, nên những hình 6 cạnh có cạnh song song với trục x và y, bài toán vẫn giữ nguyên đáp án như cũ, nhưng đã đơn giản hơn nhiều.</p>
<p>Hãy chú ý đến lúc debug nếu bạn sử dụng phương pháp này. Nhớ rằng đáp án trả về là đáp án của bài toán đã bị biến đổi, bạn cần phải trả lại đáp án cho bài toán ban đầu. Để không phải quên, bạn nên để lại một vài comment ở phần đó.</p>
<h1 id="gỡ-bỏ-những-định-nghĩa" class="toc-header"><a class="toc-anchor" href="#gỡ-bỏ-những-định-nghĩa">¶</a> Gỡ bỏ những định nghĩa</h1>
<p>Phương pháp này là một mẹo cũ của những nhà toán học, được giải quyết đối với những trường hợp đề bài được cho với hàng đống các định nghĩa chồng lên nhau, nó được sử dụng để tháo gỡ những rối rắm trong đề bài để tìm được cách tiếp cận thích hợp. Khi bạn đọc một định nghĩa nào đó mà bạn chưa bao giờ thấy trước đây, cố gắng nghĩ cách làm thế nào để code nó. Nếu chương trình yêu cầu bạn tìm ra một <em>grozmojt</em> đơn giản nhất trong tập số nguyên (ở đây <em>grozmojt</em> là một thuật ngữ không có thật để ví dụ về định nghĩa bạn chưa bao giờ thấy). Đầu tiên bạn phải tìm ra được làm sao để code của bạn nhận ra đó là một <em>grozmojt</em>, rồi sau đó tìm cách để tìm kiếm nó. Cách tiếp cận này rất giống với các tiếp cận từ dưới lên (bottom-up programming), nhưng làm việc trên định nghĩa thay vì trên các chương trình con.</p>
<p>Những bài toán mô phỏng cũng được sử dụng với các chiến thuật tương tự. Cách tốt nhất để làm những bài toán mô phỏng là tạo ra một đối tượng giống như vậy, có thể thực hiện các hành động được yêu cầu. Bằng cách đó, bạn sẽ không phải lo bạn có đưa đủ thông tin trạng thái vào các hàm hay không, bởi vì tất cả thông tin đã gói gọn trong đối tượng, cách tiếp cận này trở nên nên tiện lợi và code được atomic rất nhanh. Đây cũng là một cách tiếp cận đúng đắn nếu một thuật toán cần được mô phỏng để đếm số bước thực hiện (như MergeSort), hoặc là số đối tượng được giải phóng bộ nhớ trong các thuật toán khác (như ImmutableTrees). Trong những trường hợp như vậy, tính gọn gàng và đơn giản của code làm cho việc suy nghĩ các bước tiếp theo dễ dàng hơn.</p>
<h1 id="bài-toán-có-thể-giải-được" class="toc-header"><a class="toc-anchor" href="#bài-toán-có-thể-giải-được">¶</a> Bài toán có thể giải được</h1>
<p>Có một bài toán về hình học như thế này: bạn được cho một cặp hình tròn đồng tâm và bạn chỉ có độ dài dây cung của hình tròn bên ngoài mà tiếp tuyến với hình tròn bên trong (kí hiệu là x). Bạn được hỏi là diện tích ở giữa 2 hình tròn là bao nhiêu. Bạn nghĩ rằng: “nếu bài này có thể giải được thì bán kính của đường tròn bên trong là không cần thiết với việc tính toán, nên mình sẽ đặt nó bằng 0. Bởi vì diện tích của hình tròn bên trong bằng 0, hoặc bị làm suy biến ở tâm của hình tròn bên ngoài, nên dây cung của hình tròn bên ngoài đi qua tâm, do đó đường kính và diện tích của hình tròn ngoài bằng <svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.594ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 3356.6 1083.9" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-5-TEX-I-1D70B" d="M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z"></path><path id="MJX-5-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-5-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-5-TEX-N-2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path><path id="MJX-5-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-5-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D70B" xlink:href="#MJX-5-TEX-I-1D70B"></use></g><g data-mml-node="mo" transform="translate(570,0)"><use data-c="28" xlink:href="#MJX-5-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(959,0)"><use data-c="1D465" xlink:href="#MJX-5-TEX-I-1D465"></use></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1531,0)"><g data-mml-node="mo"><use data-c="2F" xlink:href="#MJX-5-TEX-N-2F"></use></g></g><g data-mml-node="mn" transform="translate(2031,0)"><use data-c="32" xlink:href="#MJX-5-TEX-N-32"></use></g><g data-mml-node="msup" transform="translate(2531,0)"><g data-mml-node="mo"><use data-c="29" xlink:href="#MJX-5-TEX-N-29"></use></g><g data-mml-node="TeXAtom" transform="translate(422,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-5-TEX-N-32"></use></g></g></g></g></g></svg>”. Chú ý rằng việc chứng minh toán học đầy đủ của bài này thì khó hơn, nhưng sự thật là việc đáp án có tồn tại làm cho bài toán dễ hơn. Bởi vì người ra đề phải viết đáp án cho bài toán, bạn biết rằng các bài toán đó đều có thể giải được, đó cũng là một lợi thế lớn trong những contest của SRM.</p>
<p>Cách tiếp cận này cũng áp dụng được cho suy nghĩ rằng người ra đề sẽ tìm một dạng bài toán cụ thể nào đó, và thỉnh thoảng dựa vào việc chỉnh sửa đề bài gốc, ta được gợi ý hướng làm(đặc biệt trong trường hợp khi bài toán được xem là quá khó). Một vài ví dụ như xét qua các điều kiện ban đầu của đề bài như mảng chỉ có nhiều nhất 20 phần tử (mà rất nhiều coder có kinh nghiệm sẽ nói rằng tác giả muốn bạn sử dụng brute-force cho bài này), hay giới hạn số nguyên trong khoảng từ 1 đến 10000 (cho phép nhân các số với nhau mà không tràn). Bằng việc dựa vào các điều kiện giới hạn này của đề bài, bạn sẽ giới hạn lại được độ phức tạp của bài toán và tìm ra cách tiếp cận đơn giản và tốt hơn.</p>
<p>Thỉnh thoảng độ khó của bài toán cũng có thể gợi ý được cách giải nó. Ví dụ, bài <a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=2235&amp;rd=5070&amp;rm=&amp;cr=274023" class="is-external-link">FanFailure - SRM 195 Div I</a>. Bài toán liên quan đến tập hợp con (subsets), nhiều nhất (maximal) và ít nhất (minimal), nên bạn sẽ nghĩ rằng brute-force sẽ có tác dụng, rồi sau đó bạn thấy rằng mảng nhiều nhất đến 50 phần tử. <svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.919ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 1290.1 833.9" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-6-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-6-TEX-N-35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path><path id="MJX-6-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-6-TEX-N-32"></use></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><use data-c="35" xlink:href="#MJX-6-TEX-N-35"></use><use data-c="30" xlink:href="#MJX-6-TEX-N-30" transform="translate(500,0)"></use></g></g></g></g></g></svg> tập con khác nhau sẽ làm bạn bỏ ngay cái ý tưởng brute-force (người ra đề chú trọng đến cách tư duy hơn là kĩ năng code), và tìm một cách tiếp cận khác... Nhưng khi bạn nhận ra đó là bài Div I Easy và nó cũng trông không đến nỗi khó như vậy, thì bạn sẽ nghĩ đến cách tham lam (greedy). Có thể bạn sẽ không rút ra được nhận xét đó nếu nó không phải là bài Div I Easy.</p>
<p>Hãy nhớ rằng đó chỉ là những mẹo nhỏ và không nên quan tâm nhiều đến việc tại sao nó hoạt động hay không, nó chỉ gợi ý cho ta biết rằng những gì người ra đề đang nghĩ. Hơn thế nữa, nếu người ra đề thuộc dạng người thích đánh đố, cân não người khác, thì cách này sẽ không thể dùng được. Miễn là bạn đưa ra cách tiếp cận dựa trên những lập luận logic thay vì đoán mò, thì đây cũng là một mẹo khá hữu ích.</p>
<h1 id="chia-trường-hợp" class="toc-header"><a class="toc-anchor" href="#chia-trường-hợp">¶</a> Chia trường hợp</h1>
<p>Có một số bài được giải bằng việc chia bài toán theo từng trường hợp chứ không phải theo từng bước. Bằng cách chia nhỏ bài toán thành những trường hợp, với mỗi tập đầu vào khác nhau, bạn có thể viết một hàm con để giải quyết nó và đều đó hiển nhiên là dễ hơn. Xét bài <a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=1614&amp;rd=4640&amp;rm=&amp;cr=260214" class="is-external-link">TeamPhoto - SRM 167 Div I Medium</a>. Bài này chia trường hợp đơn giản nhưng rất khó để giải. Nếu bạn chia bài toán thành những trường hợp riêng, bạn sẽ thấy rằng bài toán ban đầu không thể giải được bài thuật toán tham lam, thì mỗi trường hợp của nó có thể, và bạn có thể chọn trường hợp tối ưu nhất để đưa ra đáp án.</p>
<p>Trường hợp thường dùng cách tiếp cận này nhất là khi cần phải bỏ đi những test ở biên, để chúng ta không phải thay đổi solution chính quá nhiều. Một ví dụ là bài <a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=1848&amp;rd=4675&amp;rm=&amp;cr=272072" class="is-external-link">BirthdayOdds - SRM 174 Div I Easy</a>, rất nhiều người dùng dòng này để xử lí <code>if (daysInYears == 1) return 2;</code> cho trường hợp biên. Để tránh những trường hợp như thế, chúng ta nên xét riêng nó ra. Bằng cách thêm vào các dòng code để kiểm tra những test ở biên, độ an toàn của solution được tăng lên, và dễ dàng hơn trong việc kiểm tra cách tiếp cận đó là đúng.</p>
<h1 id="kế-hoạch-bên-trong-kế-hoạch" class="toc-header"><a class="toc-anchor" href="#kế-hoạch-bên-trong-kế-hoạch">¶</a> Kế hoạch bên trong kế hoạch</h1>
<p>Như đã nói phía trên, các cách tiếp cận một bài toán không dễ phân loại. Hơn nữa có nhiều bài phải kết hợp rất nhiều bước để đưa ra một đáp án hoàn chỉnh. Ví dụ như bài <a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=2346&amp;rd=4775&amp;rm=&amp;cr=272072" class="is-external-link">MagicianTour - SRM 191 Div I Hard</a>. Để giải được bài này cần phải làm 2 bước: bước đầu tiên cần việc tìm kiếm trên đồ thị để tìm những thành phần liên thông (connected components) và 2-coloring của nó (cách tô đồ thị chỉ bằng 2 màu), bước thứ hai phải dùng quy hoạch động giống bài toán balo. Trong những trường hợp như thế này, hãy nhớ rằng nhiều lúc sẽ cần phải áp dụng nhiều hơn một cách tiếp cận cho một bài toán. Một ví dụ khác là bài <a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=2932" class="is-external-link">TopographicalImage - SRM 210 Div II Hard</a>, bài này yêu cầu tìm góc nhỏ nhất để tính giá trị cho đường đi ngắn nhất trong một giới hạn nhất định. Để giải quyết nó, chú ý rằng việc tìm giá trị nhỏ nhất có thể làm bằng chặt nhị phân (binary search), nhưng ta cũng cần phải suy nghĩ kĩ hơn nữa, phần kế hoạch bên trong là có thể áp dụng giải thuật Floyd-Warshall để xem góc đã thỏa mãn chưa.</p>
<p>Nhớ rằng một cách tiếp cận không phải chỉ là <em>“Ồ, mình biết cách chia nhỏ bài này ... Làm thôi!”</em>. Ý tưởng cho việc tìm cách tiếp cận là suy nghĩ, lập luận có kế hoạch về: các bước cần làm trong code của bạn, áp dụng thuật toán này như thế nào, làm thế nào để lưu và truyền giá trị các biến, code có pass được trường hợp xấu nhất không, nơi nào dễ sinh ra bug nhất. Nếu chúng ta lên kế hoạch kĩ càng thì khả nắng đúng càng cao hơn. Với mỗi cách tiếp cận thì phải có những bước lên kế hoạch cho cách tiếp cận đó.</p>
<h1 id="thay-đổi-các-cách-tiếp-cận" class="toc-header"><a class="toc-anchor" href="#thay-đổi-các-cách-tiếp-cận">¶</a> Thay đổi các cách tiếp cận</h1>
<p>Không bao giờ có cách tiếp cận tốt nhất cho tất cả các coder, luôn luôn có ít nhất 2 cách để tiếp cận một vấn đề. Hãy xét bài <a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=2435&amp;rd=5852&amp;rm=&amp;cr=10225719" class="is-external-link">OhamaLow - SRM 206 Div I Easy</a>. Cách thông dụng hơn để tiếp cận bài này là thử tất cả các trường hợp xảy ra, với những cấu hình thỏa mãn yêu cầu thì sort lại và so sánh nó với đáp án để cập nhật lại đáp án. Đây là chiến thuật tìm kiếm vét cạn phổ biến nhất. Nhưng nó không chỉ có vậy, hãy nhớ rằng phải luôn có những phân tích nhỏ trong những phân tích lớn. Bạn phải tìm ra cách làm sao để tạo ra từng cấu hình (có thể cài bằng đệ quy hay sử dụng nhiều vòng lặp lồng nhau), làm thế nào để lưu những cấu hình lại (mảng, xâu, hay thậm chí dùng class) và làm thế nào để so sánh những cấu hình đó. Ở mỗi bước có rất nhiều cách để làm và hấu hết tất cả các cách làm đều chạy được. Như đã nói, có rất nhiều trường hợp ta tìm được nhiều cách xử lí khác nhau cho cùng một vấn đề. Ví dụ như bài toán yêu cầu bạn tìm một cấu hình thỏa mãn 2 điều kiện: điều kiện bắt buộc và điều kiện tối ưu. Thay vì tạo những cấu hình thỏa mãn điều kiện bắt buộc, rồi duyệt qua chọn cấu hình tối ưu nhất, ta có thể tạo ra tất cả các cấu hình, sắp xếp theo thứ tự từ tốt nhất đến xấu nhất, rồi chỉ cần chọn cấu hình đầu tiên thỏa mãn điều kiện bắt buộc. Nói cách khác, bạn lấy các xâu con 5 ký tự từ xâu "87654321" để xem shared hand và player hand có thể tạo thành chosen hand được không, nếu được thì trả lại về kết quả đó. Cách tiếp cận này cũng đòi hỏi những bước đi nhỏ (làm thế nào để kết hợp shared hand và player hand, làm thể nào để kiếm tra các cấu hình, vân vân) nhưng thỉnh thoảng (trường hợp này tốt hơn) bạn có thể chia nhỏ nó ra nhanh hơn.</p>
<p>Để có quyền chọn một trong hai cách tiếp cận, bạn phải nghĩ ra được cả hai. Cách luyện tập cho việc này là hãy tìm nhiều cách giải khác nhau của một bài toán (ví dụ như giải lại các bài SRM đã tham gia với cách giải khác). Bằng cách này, bạn sẽ tăng được khả năng tìm kiếm nhiều cách tiếp cận vấn đề, có thể đó là một cách tốt hơn, hay hơn, hay thậm chi là dễ debug hơn.</p>
<h1 id="quay-lui-các-cách-tiếp-cận-sai" class="toc-header"><a class="toc-anchor" href="#quay-lui-các-cách-tiếp-cận-sai">¶</a> Quay lui các cách tiếp cận sai</h1>
<p>Như đã nói đến ở phần trước, một bài toán có rất nhiều cách tiếp cận là điều rất thường gặp. Bạn có thể chợt nghĩ đến nó khi đang code dang dở cách hiện tại. Một trong những kĩ năng khó để luyện tập nhất khi tham gia SRM đó là khả năng để hoàn toàn tập trung vào cách tiếp cận hiện tại, không bị phân tâm bởi có nhiều cách tiếp cận khác. Nhớ rằng bạn sẽ không được thưởng thêm điểm cho việc code tối ưu hơn, hay logic hơn. Bạn lấy điểm dựa vào khả năng giải quyết được vấn đề nhanh nhất có thể. Nếu bạn nghĩ ra được một hướng giải tốt hơn hướng giải mà bạn đã code được phân nửa, hãy phân tích xem bạn sẽ mất bao nhiêu thời gian để chuyển qua hướng giải đó. Trong hầu hết trường hợp, sự thay đổi là không đáng.</p>
<p>Không hề dễ dàng cho việc tìm một hướng tiếp cận đúng đắn trong lần đầu tiên. Code một solution và debug nó dễ chịu hơn là việc nhận ra mình đã hoàn toàn đi sai hướng. Nếu bạn gặp phải trường hợp đó, bất kể là gì, đừng xóa nó. Đặt tên lại những hàm chính hay bất kì hàm con hay cấu trúc dữ liệu nào có thể chỉnh sửa được. Lí do là trong khi bạn muốn code lại hoàn toàn những dòng code <em>“sạch”</em> mới, bạn phải thừa nhận rằng những dòng code cũ có thể giống như vậy. Việc code lại sẽ làm bạn không nghĩ ra được thứ gì mới. Hơn nữa, giữ lại code cũ có thể giúp bạn test những cách tiếp cận tiếp theo, cũng như việc tạo ra test để tìm ra trường hợp sai cho các cách tiếp cận khác.</p>
<h1 id="kết-luận" class="toc-header"><a class="toc-anchor" href="#kết-luận">¶</a> Kết luận</h1>
<p>Mặc dù cần rất nhiều suy nghĩ logic, việc tìm cách tiếp cận bài toán không phải là một bộ môn khoa học, mà nó là chỉ là khả năng suy đoán với việc chuẩn bị kế hoạch tốt. Muốn đạt được hiệu quả trong việc tiếp cận bài toán cũng như tự tin hơn với đáp án của mình thì bạn phải tìm những ý tưởng sáng tạo, những suy nghĩ tỉ mỉ, cẩn thận. Việc đó sẽ tiết kiệm được nhiều thời gian cho bạn trong lúc code và debug. Khả năng tính toán trước những gì mình sẽ code trước khi chạm tay vào bàn phím chỉ có thể đạt được qua việc luyện tập, nhưng phần thưởng cho sự chăm chỉ này là khả năng giải quyết vấn đề cũng như rating sẽ lên như diều gặp gió.</p>
<h1 id="những-bài-tập-đã-đề-cập-tới" class="toc-header"><a class="toc-anchor" href="#những-bài-tập-đã-đề-cập-tới">¶</a> Những bài tập đã đề cập tới</h1>
<ul>
<li>TCI ’02 Round 2 Div I Med – <a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=511&amp;rd=4335" class="is-external-link">MatArith</a></li>
<li>SRM 170 Div I Med – <a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=1864&amp;rd=4655" class="is-external-link">CityLink</a></li>
<li>SRM 172 Div I Med – <a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=2920&amp;rd=5852" class="is-external-link">Fifteen</a></li>
<li>SRM 206 Div I Hard – <a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=2920&amp;rd=5852" class="is-external-link">HexagonIntersections</a></li>
<li>SRM 195 Div I Easy – <a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=2235&amp;rd=5070" class="is-external-link">FanFailure</a></li>
<li>SRM 167 Div I Med – <a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=1614&amp;rd=4640" class="is-external-link">TeamPhoto</a></li>
<li>SRM 174 Div I Easy – <a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=1848&amp;rd=4675" class="is-external-link">BirthdayOdds</a></li>
<li>SRM 191 Div I Hard – <a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=2346&amp;rd=4775" class="is-external-link">MagicianTour</a></li>
<li>SRM 210 Div II Hard – <a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=2932&amp;rd=5856" class="is-external-link">TopographicalImage</a></li>
<li>SRM 206 Div I Easy – <a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=2435&amp;rd=5852" class="is-external-link">OmahaLow</a></li>
</ul>
</div></template><template slot="comments"><div><comments></comments></div></template></page></div><script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'8bdcd244bea03fbc',t:'MTcyNTQ0MDc2My4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body></html>