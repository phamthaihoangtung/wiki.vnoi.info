<!DOCTYPE html><html lang="vi"><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="UTF-8"><meta name="viewport" content="user-scalable=yes, width=device-width, initial-scale=1, maximum-scale=5"><meta name="theme-color" content="#1976d2"><meta name="msapplication-TileColor" content="#1976d2"><meta name="msapplication-TileImage" content="/_assets/favicons/mstile-150x150.png"><title>Fun with Bits | VNOI Wiki</title><meta name="description" content><meta property="og:title" content="Fun with Bits"><meta property="og:type" content="website"><meta property="og:description" content><meta property="og:image"><meta property="og:url" content="wiki.vnoi.info/translate/topcoder/fun-with-bits.md"><meta property="og:site_name" content="VNOI Wiki"><link rel="apple-touch-icon" sizes="180x180" href="/_assets/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="192x192" href="/_assets/favicons/android-chrome-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/_assets/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/_assets/favicons/favicon-16x16.png"><link rel="mask-icon" href="/_assets/favicons/safari-pinned-tab.svg" color="#1976d2"><link rel="manifest" href="/_assets/manifest.json"><script>var siteConfig = {"title":"VNOI Wiki","theme":"default","darkMode":false,"tocPosition":"right","lang":"vi","rtl":false,"company":"VNOI","contentLicense":"","footerOverride":"","logoUrl":"/uploads/vnoi.svg"}
var siteLangs = []
</script><link type="text/css" rel="stylesheet" href="/_assets/css/app.14bb5aad096a8ce1a4b0.css"><script type="text/javascript" src="/_assets/js/runtime.js?1703587860"></script><script type="text/javascript" src="/_assets/js/app.js?1703587860"></script><style type="text/css">.page-col-content{max-width:1012px!important;margin-left:auto;margin-right:auto;text-align:justify}.v-main a{text-decoration:none}</style></head><body><div id="root"><page locale="vi" path="translate/topcoder/fun-with-bits" title="Fun with Bits" description :tags="[]" created-at="2023-12-25T11:07:48.163Z" updated-at="2023-12-25T12:38:19.406Z" author-name="Administrator" :author-id="1" editor="markdown" :is-published="true" toc="W3sidGl0bGUiOiJGdW4gd2l0aCBCaXRzIiwiYW5jaG9yIjoiI2Z1bi13aXRoLWJpdHMiLCJjaGlsZHJlbiI6W119LHsidGl0bGUiOiJHaeG7m2kgdGhp4buHdSIsImFuY2hvciI6IiNnaeG7m2ktdGhp4buHdSIsImNoaWxkcmVuIjpbXX0seyJ0aXRsZSI6IkPGoSBi4bqjbiIsImFuY2hvciI6IiNjxqEtYuG6o24iLCJjaGlsZHJlbiI6W119LHsidGl0bGUiOiJUw6FjaCB04burbmcgYml0IiwiYW5jaG9yIjoiI3TDoWNoLXThu6tuZy1iaXQiLCJjaGlsZHJlbiI6W119LHsidGl0bGUiOiLEkOG6v20gc+G7kSBiaXQiLCJhbmNob3IiOiIjxJHhur9tLXPhu5EtYml0IiwiY2hpbGRyZW4iOltdfSx7InRpdGxlIjoiVOG6pXQgY+G6oyBjw6FjIHThuq1wIGNvbiIsImFuY2hvciI6IiN04bqldC1j4bqjLWPDoWMtdOG6rXAtY29uIiwiY2hpbGRyZW4iOlt7InRpdGxlIjoiQ8OgaSDEkeG6t3Q6IiwiYW5jaG9yIjoiI2PDoGktxJHhurd0IiwiY2hpbGRyZW4iOltdfV19LHsidGl0bGUiOiJDaOG7iSBj4bqnbiBt4buZdCBiaXQgc2FpIGPFqW5nIDAgxJFp4buDbSIsImFuY2hvciI6IiNjaOG7iS1j4bqnbi1t4buZdC1iaXQtc2FpLWPFqW5nLTAtxJFp4buDbSIsImNoaWxkcmVuIjpbXX0seyJ0aXRsZSI6Ik3hu5l0IHPhu5EgbeG6uW8gaGF5ICh2w6AgY3V0ZSkiLCJhbmNob3IiOiIjbeG7mXQtc+G7kS1t4bq5by1oYXktdsOgLWN1dGUiLCJjaGlsZHJlbiI6W119LHsidGl0bGUiOiJCw6BpIHThuq1wIG3huqt1IiwiYW5jaG9yIjoiI2LDoGktdOG6rXAtbeG6q3UiLCJjaGlsZHJlbiI6W119XQ==" :page-id="170" sidebar="W10=" nav-mode="NONE" comments-enabled effective-permissions="eyJjb21tZW50cyI6eyJyZWFkIjp0cnVlLCJ3cml0ZSI6ZmFsc2UsIm1hbmFnZSI6ZmFsc2V9LCJoaXN0b3J5Ijp7InJlYWQiOmZhbHNlfSwic291cmNlIjp7InJlYWQiOmZhbHNlfSwicGFnZXMiOnsicmVhZCI6dHJ1ZSwid3JpdGUiOmZhbHNlLCJtYW5hZ2UiOmZhbHNlLCJkZWxldGUiOmZhbHNlLCJzY3JpcHQiOmZhbHNlLCJzdHlsZSI6ZmFsc2V9LCJzeXN0ZW0iOnsibWFuYWdlIjpmYWxzZX19" edit-shortcuts="eyJlZGl0RmFiIjpmYWxzZSwiZWRpdE1lbnVCYXIiOmZhbHNlLCJlZGl0TWVudUJ0biI6ZmFsc2UsImVkaXRNZW51RXh0ZXJuYWxCdG4iOmZhbHNlLCJlZGl0TWVudUV4dGVybmFsTmFtZSI6IiIsImVkaXRNZW51RXh0ZXJuYWxJY29uIjoiIiwiZWRpdE1lbnVFeHRlcm5hbFVybCI6IiJ9" filename="translate/topcoder/fun-with-bits.md"><template slot="contents"><div><h1 id="fun-with-bits" class="toc-header"><a class="toc-anchor" href="#fun-with-bits">¶</a> Fun with Bits</h1>
<p>Bài viết bởi <a href="https://www.topcoder.com/members/bmerry" class="is-external-link">bmerry</a>.</p>
<p>Nguồn: <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/a-bit-of-fun-fun-with-bits/" class="is-external-link">Topcoder</a></p>
<h1 id="giới-thiệu" class="toc-header"><a class="toc-anchor" href="#giới-thiệu">¶</a> Giới thiệu</h1>
<p>Hầu hết các kĩ thuật tối ưu dùng trong các kì thi Topcoder đều là những kĩ thuật cao cấp, có nghĩa là, các kĩ thuật này tối ưu trực tiếp thuật toán hơn là tối ưu cách cài đặt. Tuy nhiên, có một kĩ thuật tối ưu cơ bản nhưng sử dụng rất hiệu quả là thao tác bit (bit manipulation), hay sử dụng những bit thuộc biểu diễn của một số nguyên để biểu diễn một tập hợp. Nó không chỉ làm tăng tốc độ chạy, giảm dung lượng bộ nhớ, mà còn làm code chúng ta trở nên đơn giản hơn.</p>
<p>Mình sẽ bắt đầu bằng việc nhắc lại một số kiến thức cơ bản về bit, trước khi nghiên cứu những kĩ thuật sâu hơn.</p>
<h1 id="cơ-bản" class="toc-header"><a class="toc-anchor" href="#cơ-bản">¶</a> Cơ bản</h1>
<p>Những thứ quan trọng nhất trong thao tác bit là những toán tử trên bit (bit-wise operator): <code>&amp;</code> (and), <code>|</code> (or), <code>~</code> (not) và <code>^</code> (xor). Chắc hẳn các bạn đã quá quen với ba toán tử đầu tiên trong các phép toán logic (<code>&amp;&amp;</code>, <code>||</code>, và <code>!</code>). Dưới đây là bảng chân trị (truth tables):</p>
<div class="table-container"><table>
<tbody><tr>
<th>A</th>
<th>B</th>
<th>!A</th>
<th>A &amp;&amp; B</th>
<th>A || B</th>
<th>A ^ B</th>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table></div>
<p>Toán tử bit trên số nguyên cũng thực hiên giống vậy, chỉ khác một thứ là thay vì chuyển các tham số về true hoặc false, thì các toán tử bit được thực hiện trên các bit của các tham số. Do đó, nếu <code>A</code> là <code>1010</code> và <code>B</code> là <code>1100</code>, thì</p>
<pre class="prismjs line-numbers" data-start="1" v-pre="true"><code class="language-">A &amp; B = 1000
A | B = 1110
A ^ B = 0110
~A = 11110101 (số chữ số 1 phụ thuộc vào kiểu dữ liệu của A)
</code></pre>
<p>Hai toán tử mà chúng ta cần phải biết nữa đó là toán tử dịch bit <code>a &lt;&lt; b</code> và <code>a &gt;&gt; b</code>. Toán tử đầu tiên là dịch tất cả các bit của a sang trái b vị trí; Toán tử thứ hai cũng giống vậy nhưng dịch sang phải. Với những giá trị không âm (cũng là những số duy nhất mà ta sẽ xét đến), những bit mới xuất hiện (do dịch trái) sẽ bằng 0. Dịch trái (left-shifting) <svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.971ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 429 705" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D44F" xlink:href="#MJX-1-TEX-I-1D44F"></use></g></g></g></svg> bit đồng nghĩa với việc nhân với <svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.005ex" height="1.932ex" role="img" focusable="false" viewBox="0 -853.7 886.3 853.7" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-2-TEX-I-1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-2-TEX-N-32"></use></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D44F" xlink:href="#MJX-2-TEX-I-1D44F"></use></g></g></g></g></g></svg> và dịch phải (right-shifting) đồng nghĩa với chia nguyên cho <svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.005ex" height="1.932ex" role="img" focusable="false" viewBox="0 -853.7 886.3 853.7" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-3-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-3-TEX-I-1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-3-TEX-N-32"></use></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D44F" xlink:href="#MJX-3-TEX-I-1D44F"></use></g></g></g></g></g></svg>. Dịch bit được sử dụng nhiều nhất để truy cập vào một bit bất kì, ví dụ, <code>1 &lt;&lt; x</code> là một số nhị phân với bit thứ x bằng 1 và các bit khác bằng 0 (bit luôn luôn được đếm từ bên phải (least-significant), đếm bắt đầu từ 0).</p>
<p>Thông thường, chúng ta sẽ sử dụng một số nguyên để biểu diễn một tập hợp với miền giá trị lên đến 32 giá trị (hoặc 64 nếu sử dụng số nguyên 64 bit), với bit 1 cho biết phần tử đó có trong tập hợp và bit 0 thì không có. Sau đó thì các phép toán thì không có gì phức tạp, trong đó <code>ALL_BITS</code> trả về số bit 1, tương ứng với số phần tử có trong tập hợp:</p>
<p>Phép toán hợp (Set union)<br>
<code>A | B</code></p>
<p>Phép toán giao (Set intersection)<br>
<code>A &amp; B</code></p>
<p>Phép toán hiệu (Set subtraction)<br>
<code>A &amp; ~B</code></p>
<p>Phép toán phủ định (Set negation)<br>
<code>ALL_BIT ^ A</code></p>
<p>Gán bit bằng 1 (Set bit)<br>
<code>A |= 1 &lt;&lt; bit</code></p>
<p>Gán bit bằng 0 (Clear bit)<br>
<code>A &amp;= ~(1 &lt;&lt; bit)</code></p>
<p>Truy cập giá trị (Test bit)<br>
<code>(A &amp; 1 &lt;&lt; bit) != 0</code></p>
<h1 id="tách-từng-bit" class="toc-header"><a class="toc-anchor" href="#tách-từng-bit">¶</a> Tách từng bit</h1>
<p>Trong phần này, chúng ta sẽ bàn đến việc tìm vị trí của bit 1 cao nhất (bit 1 nằm xa nhất về bên trái) và thấp nhất (bit 1 nằm xa nhất về bên phải) trong một số. Đây là những phép toán cơ bản để tách một tập hợp ra thành những phần tử.</p>
<p>Tìm bit 1 thấp nhất khá là đơn giản, chỉ cần kết hợp đúng đắn giữa toán tử bit và phép toán số học. Giả sử chúng ta muốn tìm bit 1 thấp nhất của số x (x khác 0). Nếu chúng ta trừ 1 từ x thì bit này được xoá, nhưng tất cả các bit một khác vẫn còn. Do đó, <code>x &amp; ~(x - 1)</code> chỉ chứa duy nhất bit 1 thấp nhất của x. Tuy nhiên, cách này chỉ cho chúng ta biết giá trị của bit đó, không phải là vị trí.</p>
<p>Nếu chúng ta muốn biết vị trí của bit 1 cao nhất và thấp nhất, cách tiếp cận đơn giản nhất đó là duyệt qua các bit (từ trái qua hay từ phải qua) cho tới khi tìm được bit 1 đầu tiên. Lúc đầu, ta có thể cảm thấy cách làm này hơi chậm vì không tận dụng được lợi thế gì về bit. Tuy nhiên, nếu xác suất <svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.74ex" height="1.914ex" role="img" focusable="false" viewBox="0 -846 1210.9 846" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-4-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-4-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-4-TEX-N-32"></use></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D441" xlink:href="#MJX-4-TEX-I-1D441"></use></g></g></g></g></g></svg> tập con của miền giá trị N phần tử đều bằng nhau, thì trung bình vòng lặp chỉ cần 2 lần chạy, thật ra đây là phương pháp nhanh nhất.</p>
<p>CPU 386 có hỗ trợ duyệt bit (bit scanning): BSF (bit scan forward) và BSR (bit scan reverse). GCC cung cấp những hỗ trợ này qua những hàm xây dựng sẵn (built-in functions) <code>__builtin_ctz</code> (đếm số chữ số 0 đứng cuối) và <code>__builtin_clz</code> (đếm số chữ số 0 đứng đầu). Đây là những cách tiện lợi nhất để tìm vị trí của bit dành cho lập trình viên C++ ở Topcoder. Lưu ý: giá trị trả về là <em>undefined</em> nếu tham số đầu vào bằng 0.</p>
<p>Cuối cùng, còn một phương pháp khác để thay thế trong những testcase mà dùng vòng lặp tốn nhiều thời gian. Sử dụng mỗi byte của số nguyên 4 byte hoặc số nguyên 8 byte để tính trước bảng 256 phần tử lưu trữ vị trí của bit 1 cao nhất (thấp nhất) trong byte đó. Bit 1 cao nhất (thấp nhất) của số nguyên là giá trị lớn nhất (giá trị nhỏ nhất) của bảng này. Phương pháp này được đề cập đến để làm đa dạng thêm các phương pháp, tốc độ cũng chưa được đánh giá rõ ràng qua các kì thi Topcoder.</p>
<h1 id="đếm-số-bit" class="toc-header"><a class="toc-anchor" href="#đếm-số-bit">¶</a> Đếm số bit</h1>
<p>Chúng ta có thể dễ dàng kiểm tra một số có phải là luỹ thừa của 2 bằng cách xoá bit 1 thấp nhất và kiểm tra xem nếu kết quả có bằng 0 chưa. Tuy nhiên, trong một số trường hợp chúng ta cần phải biết có bao nhiêu bit đã được set (bit đã được set là bit 1, bit chưa được set là bit bằng 0), chúng ta cần phải thực hiện nhiều việc phức tạp hơn tí.</p>
<p>GCC có một hàm gọi là <code>__builtin_popcount</code> thực hiện đúng những thứ ta cần. Tuy nhiên, không giống như hàm <code>__builtin_ctz</code>, nó không được chuyển thành những chỉ thị trên phần cứng (ít nhất là trên x86). Thay vào đó, nó sẽ sử dụng phương pháp lưu bảng giống như trên đã trình bày để tìm kiếm bit. Phương pháp này khá là hiệu quả và cũng cực kì tiện lợi.</p>
<p>Những người dùng các ngôn ngữ khác không thể dùng cách này (mặc dù họ có thể cài đặt lại nó). Nếu một số được dự đoán rằng có rất ít bit 1, một phương pháp thay thế là chỉ cần lặp lại quá trình tìm bit 1 thấp nhất và xoá nó.</p>
<h1 id="tất-cả-các-tập-con" class="toc-header"><a class="toc-anchor" href="#tất-cả-các-tập-con">¶</a> Tất cả các tập con</h1>
<p>Một ưu điểm lớn của thao tác bit là việc duyệt qua tất cả các tập con của một tập hợp N phần tử rất đơn giản: mỗi số nguyên đại diện cho một tập con. Hơn thế nữa, nếu A là tập con của B thì số nguyên đại diện cho A sẽ nhỏ hơn số nguyên đại diện cho B, rất tiện lợi cho việc kết hợp với quy hoạch động.</p>
<p>Việc duyệt qua tất cả các tập con của một tập con khác cũng rất dễ dàng (được biểu diễn bằng một dãy bit), nếu bạn không quan tâm đến thứ tự duyệt ngược lại (hoặc có thể lưu các tập hợp vào một danh sách và đi ngược lại). Mẹo được sử dụng cũng giống như việc tìm bit 1 thấp nhất vậy. Nếu chúng ta trừ đi 1 từ tập con, thì phần tử đại diện bởi bit 1 đó sẽ được xoá, và mỗi phần tử 0 phía bên phải nó đều trở thành 1. Tuy nhiên, chúng ta chỉ muốn các phần tử được chọn là những phần tử có trong tập cha. Nên bước lặp chỉ cần thay thế ngắn gọn bằng <code>i = (i - 1) &amp; superset</code>.</p>
<h2 id="cài-đặt" class="toc-header"><a class="toc-anchor" href="#cài-đặt">¶</a> Cài đặt:</h2>
<pre class="prismjs line-numbers" data-start="1" v-pre="true"><code class="language-cpp">// xét tất cả các tập con khác rỗng của S
for (int i = S; i &gt; 0; i = (i - 1) &amp; S); {
}
</code></pre>
<h1 id="chỉ-cần-một-bit-sai-cũng-0-điểm" class="toc-header"><a class="toc-anchor" href="#chỉ-cần-một-bit-sai-cũng-0-điểm">¶</a> Chỉ cần một bit sai cũng 0 điểm</h1>
<p>Có một số lỗi mà mọi người thường mắc phải khi sử dụng các thao tác bit. Chú ý cẩn thận với code của bạn.</p>
<ol>
<li>
<p>Khi thực hiện phép toán dịch, a &lt;&lt; b, kiến trúc x86 chỉ sử dụng the 5 bit thấp nhất của b (6 cho số nguyên 64 bit). Điều này có nghĩa là dịch trái (hoặc phải) 32 bit đồng nghĩa là không làm gì cả, ngoài việc xoá tất cả các bit. Việc này cũng được nhắc đến trong Java và C#; C99 đề cập rằng việc dịch ít nhất bằng giá trị của số sẽ trả về kết quả là undefined. Lịch sử: máy 8086 sử dụng full shift register, thường thao tác này còn được dùng để kiểm tra processor mới.</p>
</li>
<li>
<p>Toán tử <code>&amp;</code> và <code>|</code> có độ ưu tiên thực hiện thấp hơn phép so sánh. Điều đó có nghĩa là <code>x &amp; 3 == 1</code> bằng với <code>x &amp; (3 == 1)</code>, đây là những lỗi bạn không hề muốn mắc phải.</p>
</li>
<li>
<p>Nếu bạn muốn viết những dòng code C/C++ dùng ở nhiều nơi, hãy đảm bảo rằng bạn sử dụng kiểu unsigned, cụ thể trong trường hợp bạn có ý định sử dụng bit cao nhất (top-most). C99 nói rằng dịch bit trên giá trị âm sẽ trả về undefined. Java chỉ có kiểu dữ liệu có dấu: <code>&gt;&gt;</code> sẽ tự động thay đổi dấu của giá trị nếu cần thiết (nhưng đây là thứ bạn thường không muốn xảy ra), nhưng toán tử đặc biệt này của Java là <code>&gt;&gt;&gt;</code> sẽ thêm các số 0 vào phía trước sau khi dịch.</p>
</li>
</ol>
<h1 id="một-số-mẹo-hay-và-cute" class="toc-header"><a class="toc-anchor" href="#một-số-mẹo-hay-và-cute">¶</a> Một số mẹo hay (và cute)</h1>
<p>Có một số mẹo hay có thể sử dụng với thao tác bit.<br>
Những mẹo này khá hay để đem đi chém gió với bạn bè, nhưng thông thường hiệu quả cũng không cải thiện lắm ở thực tế.</p>
<p><strong>Đảo thứ tự các bit trong một số nguyên</strong></p>
<pre class="prismjs line-numbers" data-start="1" v-pre="true"><code class="language-">x = ((x &amp; 0xaaaaaaaa) &gt;&gt; 1) | ((x &amp; 0x55555555) &lt;&lt; 1);
x = ((x &amp; 0xcccccccc) &gt;&gt; 2) | ((x &amp; 0x33333333) &lt;&lt; 2);
x = ((x &amp; 0xf0f0f0f0) &gt;&gt; 4) | ((x &amp; 0x0f0f0f0f) &lt;&lt; 4);
x = ((x &amp; 0xff00ff00) &gt;&gt; 8) | ((x &amp; 0x00ff00ff) &lt;&lt; 8);
x = ((x &amp; 0xffff0000) &gt;&gt; 16) | ((x &amp; 0x0000ffff) &lt;&lt; 16);
</code></pre>
<p>Bài tập là bạn hãy dùng kĩ thuật phía trên để đếm số bit với kiểu dữ liệu word.</p>
<p><strong>Duyệt qua tất cả các tập con có k phần tử</strong></p>
<pre class="prismjs line-numbers" data-start="1" v-pre="true"><code class="language-">int s = (1 &lt;&lt; k) - 1;
while (!(s &amp; 1 &lt;&lt; N))
{
    //làm gì đó với s
    int lo = s &amp; ~(s - 1);   //bit 1 thấp nhất
    int lz = (s + lo) &amp; ~s;  //bit 0 thấp nhất trên lo
    s |= lz;                       //thêm lz vào tập hợp
    s &amp;= ~(lz - 1);             //reset bit phía dưới lz
    s |= (lz / lo / 2) - 1;     //đặt lại đúng số bit ở cuối
}
</code></pre>
<p>Trong C, dòng cuối có thể viết là <code>s |= (lz &gt;&gt; ffs(lo)) - 1</code> để tránh phép chia.</p>
<p>Xác định <code>x ? y : -y</code>, trong đó x bằng 0 hoặc 1<br>
<code>(-x ^ y) + x</code></p>
<p>Câu lệnh trên chạy được trên kiến trúc số bù 2 (tồn tại ở hầu hết các máy tính bạn thấy ngày nay), trong đó số âm được biểu diễn bằng cách đảo tất cả các bit và cộng thêm cho 1. Chú ý rằng trên i686 và trước đó, câu lệnh này chạy khá hiệu quả (không cần rẽ nhánh ) nhờ vào lệnh <code>CMOVE</code> (di chuyển có điều kiện).</p>
<h1 id="bài-tập-mẫu" class="toc-header"><a class="toc-anchor" href="#bài-tập-mẫu">¶</a> Bài tập mẫu</h1>
<p><a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=6725&amp;rd=10100" class="is-external-link">TCCC 2006, Round 1B Medium</a></p>
<p>Với mỗi thành phố, giữ một bit-set của những thành phố kề nó. Một khi một phần của nhà máy đã được chọn (đệ quy), AND những bit-set đó lại sẽ cho ra một bit-set mới mô tả những vị trí có thể của những phần của nhà máy. Nếu bit-set này có k bit, thì có <svg style="vertical-align: -0.576ex;" xmlns="http://www.w3.org/2000/svg" width="3.21ex" height="2.508ex" role="img" focusable="false" viewBox="0 -853.7 1418.8 1108.5" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-5-TEX-I-1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path><path id="MJX-5-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path><path id="MJX-5-TEX-I-1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msubsup"><g data-mml-node="mi"><use data-c="1D436" xlink:href="#MJX-5-TEX-I-1D436"></use></g><g data-mml-node="mi" transform="translate(845.3,363) scale(0.707)"><use data-c="1D458" xlink:href="#MJX-5-TEX-I-1D458"></use></g><g data-mml-node="mi" transform="translate(748,-247) scale(0.707)"><use data-c="1D45A" xlink:href="#MJX-5-TEX-I-1D45A"></use></g></g></g></g></svg> cách để chọn các phần của nhà máy.</p>
<p><a href="http://www.topcoder.com/stat?c=problem_statement&amp;pm=6095&amp;rd=9917" class="is-external-link">TCO 2006, Round 1 Easy</a></p>
<p>Số lượng nút nhỏ cho thấy rằng bài này có thể giải quyết bằng việc xét tất cả các tập con. Với mỗi tập con ta xét 2 trường hợp: nút nhỏ nhất không có trao đổi gì cả, trong trường hợp ta xét tập con mà không có nó, hoặc nó trao đổi với một số nút, ta sẽ xét các tập hợp không có nó và các nút mà nó trao đổi. Code bài giải rất ngắn gọn:</p>
<pre class="prismjs line-numbers" data-start="1" v-pre="true"><code class="language-">static int dp[1 &lt;&lt; 18];

int SeparateConnections::howMany(vector &lt;string&gt; mat)
{
    int N = mat.size();
    int N2 = 1 &lt;&lt; N;
    dp[0] = 0;
    for (int i = 1; i &lt; N2; i++)
    {
        int bot = i &amp; ~(i - 1);
        int use = __builtin_ctz(bot);
        dp[i] = dp[i ^ bot];
        for (int j = use + 1; j &lt; N; j++)
            if ((i &amp; (1 &lt;&lt; j)) &amp;&amp; mat[use][j] == 'Y')
                dp[i] = max(dp[i], dp[i ^ bot ^ (1 &lt;&lt; j)] + 2);
    }
    return dp[N2 - 1];
}
</code></pre>
<p><a href="http://www.topcoder.com/stat?c=problem_statement&amp;pm=6475&amp;rd=9988" class="is-external-link">SRM 308, Division Medium</a></p>
<p>Cái bảng chứa 36 hình vuông và những con cờ không thể phân biệt được, nên những vị trí có thể được mã hoá vào số nguyên 64 bit. Bước đầu tiên là liệt kê tất cả các bước đi hợp lệ. Bất kì bước đi hợp lệ nào cũng đều được mã hoá sử dụng 3 trường: 1 trạng thái trước, 1 trạng thái sau và một mask dùng để định nghĩa phần nào của trạng thái trước là quan trọng. Một bước đi có thể được tạo ra từ trạng thái hiện tại nếu <code>(current &amp; mask) == before</code>. Nếu nó được tạo ra, thì trạng thái mới là <code>(current &amp; ~mask) | after</code>.</p>
<p><a href="http://www.topcoder.com/stat?c=problem_statement&amp;pm=6400&amp;rd=10000" class="is-external-link">SRM 320, Division 1 Hard</a></p>
<p>Điều kiện cho ta biết rằng chỉ có nhiều nhất 8 cột (nếu có nhiều hơn, ta có thể đổi giữa dòng và cột), nên chúng ta có thể xét từng cách để một dòng. Một khi chúng ta có thông tin này, ta có thể giải quyết vấn đề còn lại của bài toán (xem <a href="http://www.topcoder.com/tc?module=Static&amp;d1=match_editorials&amp;d2=srm320" class="is-external-link">tutorial</a> để biết thêm chi tiết). Do đó ta cần một danh sách tất cả số nguyên n bit mà không có 2 bit 1 kề nhau, và ta cũng cần biết có bao nhiêu bit 1 trong mỗi dòng như vậy. Đây là code của mình:</p>
<pre class="prismjs line-numbers" data-start="1" v-pre="true"><code class="language-">for (int i = 0; i &lt; (1 &lt;&lt; n); i++)
{
    if (i &amp; (i &lt;&lt; 1)) continue;
    pg.push_back(i);
    pgb.push_back(__builtin_popcount(i));
}
</code></pre>
</div></template><template slot="comments"><div><comments></comments></div></template></page></div><script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'8bdd81eb6be6797d',t:'MTcyNTQ0Nzk1OC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body></html>